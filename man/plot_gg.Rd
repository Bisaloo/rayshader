% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_gg.R
\name{plot_gg}
\alias{plot_gg}
\title{Transform ggplot2 objects into 3D}
\usage{
plot_gg(
  ggobj,
  width = 3,
  height = 3,
  height_aes = NULL,
  invert = FALSE,
  shadow_intensity = 0.5,
  units = c("in", "cm", "mm"),
  scale = 150,
  pointcontract = 0.7,
  offset_edges = FALSE,
  preview = FALSE,
  raytrace = TRUE,
  sunangle = 315,
  anglebreaks = seq(30, 40, 0.1),
  multicore = FALSE,
  lambert = TRUE,
  reduce_size = NULL,
  save_height_matrix = FALSE,
  save_shadow_matrix = FALSE,
  saved_shadow_matrix = NULL,
  ...
)
}
\arguments{
\item{ggobj}{ggplot object to projected into 3D.}

\item{width}{Default \code{3}. Width of ggplot, in \code{units}.}

\item{height}{Default \code{3}. Height of ggplot, in \code{units}.}

\item{height_aes}{Default \code{NULL}. Whether the \code{fill} or \code{color} aesthetic should be used for height values,
which the user can specify by passing either \code{fill} or \code{color} to this argument.
Automatically detected. If both \code{fill} and \code{color} aesthetics are present, then \code{fill} is default.}

\item{invert}{Default \code{FALSE}. If \code{TRUE}, the height mapping is inverted.}

\item{shadow_intensity}{Default \code{0.5}. The intensity of the calculated shadows.}

\item{units}{Default \verb{in}. One of c("in", "cm", "mm").}

\item{scale}{Default \code{150}. Multiplier for vertical scaling: a higher number increases the height
of the 3D transformation.}

\item{pointcontract}{Default \code{0.7}. This multiplies the size of the points and shrinks
them around their center in the 3D surface mapping. Decrease this to reduce color bleed on edges, and set to
\code{1} to turn off entirely. Note: If \code{size} is passed as an aesthetic to the same geom
that is being mapped to elevation, this scaling will not be applied. If \code{alpha} varies on the variable
being mapped, you may want to set this to \code{1}, since the points now have a non-zero width stroke outline (however,
mapping \code{alpha} in the same variable you are projecting to height is probably not a good choice. as the \code{alpha}
variable is ignored when performing the 3D projection).}

\item{offset_edges}{Default \code{FALSE}. If \code{TRUE}, inserts a small amount of space between polygons for "geom_sf", "geom_tile", "geom_hex", and "geom_polygon" layers.
If you pass in a number, the space between polygons will be a line of that width. Note: this feature may end up removing thin polygons
from the plot entirely--use with care.}

\item{preview}{Default \code{FALSE}. If \code{TRUE}, the raytraced 2D ggplot will be displayed on the current device.}

\item{raytrace}{Default \code{FALSE}. Whether to add a raytraced layer.}

\item{sunangle}{Default \code{315} (NW). If raytracing, the angle (in degrees) around the matrix from which the light originates.}

\item{anglebreaks}{Default \code{seq(30,40,0.1)}. The azimuth angle(s), in degrees, as measured from the horizon from which the light originates.}

\item{multicore}{Default \code{FALSE}. If raytracing and \code{TRUE}, multiple cores will be used to compute the shadow matrix. By default, this uses all cores available, unless the user has
set \code{options("cores")} in which the multicore option will only use that many cores.}

\item{lambert}{Default \code{TRUE}. If raytracing, changes the intensity of the light at each point based proportional to the
dot product of the ray direction and the surface normal at that point. Zeros out all values directed away from
the ray.}

\item{reduce_size}{Default \code{NULL}. A number between 0 and 1 that specifies how much to reduce the resolution of the plot, for faster plotting.}

\item{save_height_matrix}{Default \code{FALSE}. If \code{TRUE}, the function will return the height matrix used for the ggplot.}

\item{save_shadow_matrix}{Default \code{FALSE}. If \code{TRUE}, the function will return the shadow matrix for use in future updates via the \code{shadow_cache} argument passed to \code{ray_shade}.}

\item{saved_shadow_matrix}{Default \code{NULL}. A cached shadow matrix (saved by the a previous invocation of \code{plot_gg(..., save_shadow_matrix=TRUE)} to use instead of raytracing a shadow map each time.}

\item{...}{Additional arguments to be passed to \code{\link[=plot_3d]{plot_3d()}}.}
}
\value{
Opens a 3D plot in rgl.
}
\description{
Plots a ggplot2 object in 3D by mapping the color or fill aesthetic to elevation.

Currently, this function does not transform lines mapped to color into 3D.

If there are multiple legends/guides due to multiple aesthetics being mapped (e.g. color and shape),
the package author recommends that the user pass the order of the guides manually using the ggplot2 function "guides()`.
Otherwise, the order may change when processing the ggplot2 object and result in a mismatch between the 3D mapping
and the underlying plot.

Using the shape aesthetic with more than three groups is not recommended, unless the user passes in
custom, solid shapes. By default in ggplot2, only the first three shapes are solid, which is a requirement to be projected
into 3D.
}
\examples{
library(ggplot2)
library(viridis)

ggdiamonds = ggplot(diamonds, aes(x, depth)) +
 stat_density_2d(aes(fill = stat(nlevel)), geom = "polygon", n = 100, bins = 10,contour = TRUE) +
 facet_wrap(clarity~.) +
 scale_fill_viridis_c(option = "A")
\donttest{
plot_gg(ggdiamonds,multicore=TRUE,width=5,height=5,scale=250,windowsize=c(1400,866),
       zoom = 0.55, phi = 30)
render_snapshot()
}

#Change the camera angle and take a snapshot:
\donttest{
render_camera(zoom=0.5,theta=-30,phi=30)
render_snapshot(clear = TRUE)
}

#Contours and other lines will automatically be ignored. Here is the volcano dataset:

ggvolcano = volcano \%>\% 
 reshape2::melt() \%>\%
 ggplot() +
 geom_tile(aes(x=Var1,y=Var2,fill=value)) +
 geom_contour(aes(x=Var1,y=Var2,z=value),color="black") +
 scale_x_continuous("X",expand = c(0,0)) +
 scale_y_continuous("Y",expand = c(0,0)) +
 scale_fill_gradientn("Z",colours = terrain.colors(10)) +
 coord_fixed()
ggvolcano

\donttest{
plot_gg(ggvolcano, multicore = TRUE, raytrace = TRUE, width = 7, height = 4, 
       scale = 300, windowsize = c(1400, 866), zoom = 0.6, phi = 30, theta = 30)
render_snapshot(clear = TRUE)
}

#Here, we will create a 3D plot of the mtcars dataset. This automatically detects 
#that the user used the `color` aesthetic instead of the `fill`.
mtplot = ggplot(mtcars) + 
 geom_point(aes(x=mpg,y=disp,color=cyl)) + 
 scale_color_continuous(limits=c(0,8)) 

#Preview how the plot will look by setting `preview = TRUE`: We also adjust the angle of the light.
\donttest{
plot_gg(mtplot, width=3.5, sunangle=225, preview = TRUE)
}

\donttest{
plot_gg(mtplot, width=3.5, multicore = TRUE, windowsize = c(1400,866), sunangle=225,
       zoom = 0.60, phi = 30, theta = 45)
render_snapshot(clear = TRUE)
}

#Now let's plot a density plot in 3D.
mtplot_density = ggplot(mtcars) + 
 stat_density_2d(aes(x=mpg,y=disp, fill=..density..), geom = "raster", contour = FALSE) +
 scale_x_continuous(expand=c(0,0)) +
 scale_y_continuous(expand=c(0,0)) +
 scale_fill_gradient(low="pink", high="red")
mtplot_density

\donttest{
plot_gg(mtplot_density, width = 4,zoom = 0.60, theta = -45, phi = 30, 
       windowsize = c(1400,866))
render_snapshot(clear = TRUE)
}

#This also works facetted.
mtplot_density_facet = mtplot_density + facet_wrap(~cyl) 

#Preview this plot in 2D:
\donttest{
plot_gg(mtplot_density_facet, preview = TRUE)
}

\donttest{
plot_gg(mtplot_density_facet, windowsize=c(1400,866),
       zoom = 0.55, theta = -10, phi = 25)
render_snapshot(clear = TRUE)
}

#That is a little cramped. Specifying a larger width will improve the readability of this plot.
\donttest{
plot_gg(mtplot_density_facet, width = 6, preview = TRUE)
}

#That's better. Let's plot it in 3D, and increase the scale.
\donttest{
plot_gg(mtplot_density_facet, width = 6, windowsize=c(1400,866),
       zoom = 0.55, theta = -10, phi = 25, scale=300)
render_snapshot(clear = TRUE)
}
}
